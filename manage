#!/usr/bin/env bash
# -*- coding: utf-8; mode: sh indent-tabs-mode: nil -*-
# SPDX-License-Identifier: AGPL-3.0-or-later
# shellcheck disable=SC2031

if [[ -z "${REPO_ROOT}" ]]; then
    REPO_ROOT=$(dirname "${BASH_SOURCE[0]}")
    while [ -h "${REPO_ROOT}" ] ; do
        REPO_ROOT=$(readlink "${REPO_ROOT}")
    done
    REPO_ROOT=$(cd "${REPO_ROOT}" && pwd -P )
fi

if [ "$VERBOSE" = "1" ]; then
    SPHINX_VERBOSE="-v"
    PYLINT_VERBOSE="-v"
fi

# shellcheck source=makefile.lib/0_toolbox.sh
source "$(dirname "${BASH_SOURCE[0]}")/makefile.lib/0_toolbox.sh"

# shellcheck source=makefile.lib/1_pyenv.sh
source "$(dirname "${BASH_SOURCE[0]}")/makefile.lib/1_pyenv.sh"

# shellcheck source=makefile.lib/babel.sh
source "$(dirname "${BASH_SOURCE[0]}")/makefile.lib/babel.sh"

# shellcheck source=makefile.lib/data.sh
source "$(dirname "${BASH_SOURCE[0]}")/makefile.lib/data.sh"

# shellcheck source=makefile.lib/docs.sh
source "$(dirname "${BASH_SOURCE[0]}")/makefile.lib/docs.sh"

# shellcheck source=makefile.lib/docker.sh
source "$(dirname "${BASH_SOURCE[0]}")/makefile.lib/docker.sh"

# shellcheck source=makefile.lib/static.sh
source "$(dirname "${BASH_SOURCE[0]}")/makefile.lib/static.sh"

# shellcheck source=makefile.lib/test.sh
source "$(dirname "${BASH_SOURCE[0]}")/makefile.lib/test.sh"

# shellcheck source=makefile.lib/themes.sh
source "$(dirname "${BASH_SOURCE[0]}")/makefile.lib/themes.sh"

help() {
    cat <<EOF
buildenv:
  rebuild ./utils/brand.env
babel.compile:
  pybabel compile ./searx/translations
data.:
  all       : update searx/languages.py and ./data/*
  languages : update searx/data/engines_languages.json & searx/languages.py
  useragents: update searx/data/useragents.json with the most recent versions of Firefox.
docs.:
  html      : build HTML documentation
  live      : autobuild HTML documentation while editing
  gh-pages  : deploy on gh-pages branch
  prebuild  : build reST include files (./${DOCS_BUILD}/includes)
  clean     : clean documentation build
docker.:
  build     : build docker image
  push      : build and push docker image
gecko.driver:
  download & install geckodriver if not already installed (required for
  robot_tests)
node.:
  env       : download & install npm dependencies locally
  clean     : drop npm installations
py.:
  clean     : delete virtualenv and intermediate py files
pyenv.:
  install   : developer install of searx into virtualenv
  uninstall : uninstall developer installation
  cmd ...   : run command ... in virtualenv
  OK        : test if virtualenv is OK
test.:
  pylint    : lint PYLINT_FILES, searx/engines, searx & tests
  pep8      : pycodestyle (pep8) for all files except PYLINT_FILES
  unit      : run unit tests
  coverage  : run unit tests with coverage
  robot     : run robot test
  clean     : clean intermediate test stuff
themes.:
  all       : build all themes
  oscar     : build oscar theme
  simple    : build simple theme
pygments.:
  less      : build LESS files for pygments
static.build.:  ${STATIC_BUILD_COMMIT}
  commit    : build & commit /static folder
  drop      : drop last commit if it was previously done by static.build.commit
  restore   : git restore of the /static folder (after themes.all)
EOF
}


buildenv() {

    # settings file from repository's working tree are used by default
    SEARX_SETTINGS_PATH="${REPO_ROOT}/searx/settings.yml"

    if [ -r '/etc/searx/settings.yml' ]; then
        if ask_yn "should settings read from: /etc/searx/settings.yml"; then
            SEARX_SETTINGS_PATH='/etc/searx/settings.yml'
        fi
    fi
    export SEARX_SETTINGS_PATH
    (
        set -e
        SEARX_DEBUG=1 pyenv.cmd python utils/build_env.py 2>&1 \
            | prefix_stdout "${_Blue}BUILDENV${_creset}  "
    )
    return "${PIPESTATUS[0]}"
}

# shellcheck disable=SC2119
main() {

    local _type
    local cmd="$1"; shift

    if [ "$cmd" == "" ]; then
        help
        err_msg "missing command"
        return 42
    fi

    case "$cmd" in
        --getenv) var="$1"; echo "${!var}";;
        --help) help;;
        --*)
            help
            err_msg "unknown option $cmd"
            return 42
            ;;
        *)
            _type="$(type -t "$cmd")"
            if [ "$_type" != 'function' ]; then
                err_msg "unknown command: $cmd / use --help"
                return 42
            else
                "$cmd" "$@"
            fi
            ;;
    esac
}

main "$@"
